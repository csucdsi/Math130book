---
execute:
  fig-height: 4
format: 
  html:
    toc-depth: 3
---
# Plot Enhancements {#sec-plots2}

:::{.callout-warning icon=false appearance=minimal}
<a href="https://media.csuchico.edu/media/MATH+130+-+Lecture+10A+Introduction/1_qmt3ls9l" target="_blank">Lesson Introduction Video</a>
:::

Section @sec-plots1 introduced the main plotting packages `ggplot2`, `ggpubr`, and `sjPlot` and focused on creating the correct graphics for the data types. This lesson expands on those tools and demonstrates how to customize some features and add enhancements to clarify or to add information to a plot. 

:::{.callout-note title = "ðŸŽ“ Learning Objectives" icon=false}

After completing this lesson students will be able to

* Change the color and shape of geometries in a plot
* Layer on multiple types of geometries onto a single plot
* Create a grid/panel of plots to create multivarible plots
* Adjust themes, legends, and titles

:::

:::{.callout-important title = "Too much to memorize!"}
There is *NO* need to remember all of these adjustments when there are incredibly handy reference guides and "cookbooks" available. 

* https://r-graphics.org/
* https://r-graph-gallery.com
* https://ggplot2.tidyverse.org/reference/index.html 
* https://r-charts.com

This lesson also has no specific order, but is a smattering of "things you should know". 
:::

:::{.callout-tip title = "ðŸ‘‰ Prepare" icon=false}

1.  Open your Math 130 R Project.
2.  Right click and "save as" this lessons [[Quarto notes file]](notes/plots2_notes.qmd) and save into your `Math130/notes` folder.
3.  In the *Files* pane, open this Quarto file and Render this file.

```{r}
library(tidyverse) # ggplot, forcats
library(ggpubr)
email <- openintro::email
library(paletteer)
NCbirths <- openintro::ncbirths
pen <- palmerpenguins::penguins
```

:::

This lesson uses several data sets that we have seen in prior lessons. 

## Reorder barcharts in decreasing order

We can reorder these levels on the fly so they are being shown in decreasing frequency using the `fct_infreq` function from the `forcats` library. You can add this layer to both `ggplot` and `ggpubr` creations. 

```{r}
#| source-line-numbers: "2"
ggplot(pen, aes(
  x=fct_infreq(island))) + 
  geom_bar() + xlab("Island")
```
## Flipping the axis

Sometimes barcharts and boxplots look better horizontally, especially when the category labels are long,  but the default is vertical. We can add a `coord_flip` layer to nearly any plot to rotate it 90*. 


```{r}
#| layout-ncol: 2
ggplot(pen, aes(x=island)) + geom_bar() +  
  coord_flip()

ggboxplot(pen, y= "body_mass_g", x = "island") + 
    coord_flip()
```


## A "better" Pie chart

We need to pre-calculate the percentages first, then plot those summary numbers. So we will chain functions from `dplyr` and `ggpubr` together. 

[See the [R graph gallery](https://r-graph-gallery.com/piechart-ggplot2.html) for how to make a pie chart in `ggplot`.]{.aside}

```{r}
#| code-annotations: below
pen %>%  # <1>
  group_by(island) %>%  # <2>
  tally() %>% # <3>
  mutate(pct = scales::percent(n/sum(n)),  # <4>
         labs = paste0(island, "\n n=", n, "(", pct, ")")) %>%  # <5>
  ggpie(x = "n",  # <6>
        label = "labs",  # <7>
        fill = "island",  # <8>
        lab.pos = "in") # <9>
```

1. Take the `penguin` data set
2. perform these calculations for each `island` separately
3. `tally()` counts the number of records by group (like `table`), and stores it in a new variable named `n` (this is a default name)
4. create a new variable `pct` that calculates the percent in each group by dividing the group count `n`, by the total number of records `sum(n)`, then using the `percent` function from the `scales` package to display this decimal as a percent
5. Create chart labels by `paste`ing the value of the variable `island`, then a line break (new line) `\n`, then the text `n=`, then the value of the variable `n`, followed by the value of the percent variable `pct` wrapped in parenthesis
6. pass all of this summarized data into `ggpie` - the function to create the pie chart, and specify that the numbers to be plotted is in the variable `n`
7. and that the wedge labels are found in the variable `labs` that was created in step 5
8. color the wedges based on the `island` variable
9. and put these labels inside the circle


## Adding the mean

Adding annotation on a numeric distribution plot to indicate where the mean is located is often a nice informative feature. 

::: {.panel-tabset}
## ggplot2

The mean can be denoted on `geom_histogram` or `geom_density` using a vertical line (`geom_vline`) where the `xintercept` is set as the calculated mean of the variable being plotted. 

With boxplots and violins, the code below uses the `stat_summary` layer to add the `mean` as a summary `fun`ction, we plot it as a `point` on the graph, `shape=17` makes it a triangle (see `?pch` for more shapes), `size=4` makes it a bit larger so it stands out. There are also `color` and `fill` options available if desired. 

```{r}
#| source-line-numbers: "3-4, 8-10"
#| layout-ncol: 2
#| fig-cap: 
#|   - "using `geom_vline` to add to a histogram or density"
#|   - "using `stat_summary` to add the mean to a boxplot"
ggplot(pen, aes(x=body_mass_g)) + 
  geom_histogram() + 
  geom_vline(aes(xintercept=mean(body_mass_g, na.rm = TRUE)),
            color="blue", linetype="dashed")

ggplot(pen, aes(y=body_mass_g, x = island)) + 
  geom_boxplot() + 
  stat_summary(fun="mean", geom="point", 
               shape=17, size=4) 
```

Play around with the `shape`, `fill`/`color`, and `size` until you achieve your desired look. 

## ggpubr

With `ggpubr` you can use use the `add="mean"` argument to both `gghistogram` and `ggdensity` to add a vertical dashed line to denote the location of the mean.  

```{r}
#| source-line-numbers: "2,4"
#| layout-ncol: 2
gghistogram(pen, x="body_mass_g", fill = "species",
            add = "mean",)
ggboxplot(pen, y="body_mass_g", x = "species", fill = "species", 
          add = "mean_se", add.params = list(color = "white"))
```

With `ggpboxplot`, you can `add` many summary statistics such as the mean as a dot and line representing uncertainty such as the standard deviation (sd) and standard error (se). I also used `add.params` to make the color of these means easier to see. 
See the `add` and `add.params` entries in the help file for `?ggboxplot` for more options. 

:::

### Histograms + density curve

Often it is more helpful to have the density (or kernel density) plot _on top of_ a histogram plot. 

::: {.panel-tabset}
## `ggplot2`

```{r}
#| code-annotations: below
ggplot(pen, aes(x=body_mass_g)) +   # <1>
  geom_density(col="blue") + 
  geom_histogram(aes(y=..density..), colour="black", # <2>
                 fill=NA) # <3>
```

1. The syntax starts the same: we'll add a `geom_density` and color the line blue for funsies. 
2. Then we add the histogram geom using `geom_histogram` but must specify that the y axis should be on the density, not frequency, scale. Note that this has to go inside the aesthetic statement `aes()`. 
3. I'm also going to get rid of the fill by using `NA` so the colored bars don't plot over the density line. 

## `ggpubr`

You start with a `gghistogram` and then `add_denstity` to the plot. This does not always work well with every variable. Sometimes the density plot is too small to view. 

```{r}
#| source-line-numbers: "2"
gghistogram(pen, x = "bill_depth_mm", fill = "species", 
            add_density = TRUE)
```

:::


## Adding violins to a boxplot

A violin plot is like a density plot, turned on its side, and reflected around the axis for symmetry purposes. Overlaying a boxplot and a violin plot serves a similar purpose to Histograms + Density plots. It shows outliers, the location of most the data, and better shows the shape/skew of the distribution.

::: {.panel-tabset}
## ggplot2

```{r}
ggplot(pen, aes(x=body_mass_g, y=island, fill=island)) +
        geom_violin(alpha=.1) + 
        geom_boxplot(alpha=.5, width=.2)
```

## ggpubr

We start with a `ggviolin` and then add a `boxplot`. Note that I also add `coord_flip()` to change the orientation of the boxplots to horizontal. 
```{r}
ggviolin(pen, 
  x="island", y = "body_mass_g", 
  color = "island", add = c("mean", "boxplot")) + 
  coord_flip()
```

:::



## Themes 

:::{.callout-warning icon=false appearance=minimal}
<a href="https://media.csuchico.edu/media/MATH+130+-+Lecture+10A+Themes/1_kwh2ucf7" target="_blank">Themes Video</a>
:::

The standard theme has a gray background, white grid lines etc. 
Themes can be changed by adding `theme_X()` where `X` has several options

```{r}
#| layout-ncol: 3
#| source-line-numbers: "2, 4, 6"
#| fig-subcap: 
#|  - "theme_bw()"
#|  - "theme_void()"
#|  - "theme_dark()"
ggplot(email, aes(x=line_breaks, y=num_char)) + geom_point() + 
  theme_bw()
ggplot(email, aes(x=line_breaks, y=num_char)) + geom_point() + 
  theme_void()
ggplot(email, aes(x=line_breaks, y=num_char)) + geom_point() + 
  theme_dark()
```

Explore tons more themes at [https://r-charts.com/ggplot2/themes/](https://r-charts.com/ggplot2/themes/)

## Legends (keys)

:::{.callout-warning icon=false appearance=minimal}
<a href="https://media.csuchico.edu/media/MATH+130+-+Lecture+10A+Legends/1_schkl6as" target="_blank">Modifying plot legends video</a>
:::


### Title of legend

Add the `name=` argument to whatever layer you added that created the legend. Here I specified a `fill`, and it was a `discrete` variable. So I use the `scale_fill_discrete()` layer. 

```{r}
#| source-line-numbers: "2"
ggplot(email, aes(y=num_char, x=number, fill=number)) + geom_boxplot() + 
  scale_fill_discrete(name="Size of number")
```

Here I `col`or the box outlines so the layer is `scale_color_discrete()`.
```{r}
#| source-line-numbers: "2"
ggplot(email, aes(y=num_char, x=number, col=number)) + geom_boxplot() + 
  scale_color_discrete(name="Size of number")
```


### Moving & removing the legend

::: {.panel-tabset}
## Moving

The `legend.position` can be controlled using a `theme()` layer. 

```{r}
#| source-line-numbers: "2"
ggplot(email, aes(y=num_char, x=number, col=number)) + geom_boxplot() + 
  theme(legend.position = "top") 
```

Note that this involves a call to `theme()`. If you have apply a named theme like `theme_bw()` _after_ setting legend.position using `theme`, it will overwrite that modification. The order of ggplot layers matters. 

```{r}
#| source-line-numbers: "2-3"
#| layout-ncol: 2
ggplot(email, aes(y=num_char, x=number, col=number)) + geom_boxplot() + 
  theme(legend.position = "top") + 
  theme_minimal()

ggplot(email, aes(y=num_char, x=number, col=number)) + geom_boxplot() + 
  theme_minimal() + 
  theme(legend.position = "top")
```

## Removing

Sometimes the legend is not needed. It's providing redundant information and takes up space, so let's remove it entirely by adding `guide="none"` to the `scale_` layer. 

```{r}
#| source-line-numbers: "2"
ggplot(email, aes(y=num_char, x=number, col=number)) + geom_boxplot() + 
  scale_color_discrete(guide="none")
```
:::


## Title and axis labels

:::{.callout-warning icon=false appearance=minimal}
<a href="https://media.csuchico.edu/media/MATH+130+-+Lecture+10A+Titles/1_xvnu92g7" target="_blank">Lesson Video</a>
:::

A good plot needs to stand alone and convey as much information as possible. `ggplot2` provides a single `labs` function that is very versitile and includes options for alt-text as well. See `?labs` for more information

* `title` for an overall plot title
* `y` and `x` adjust the axis labels. 
* using `\n` creates a line break

```{r}
#| source-line-numbers: "4-6"
ggplot(email, aes(y=num_char, x=number, col=number)) + 
  geom_boxplot() + 
  scale_color_discrete(guide="none") + 
  labs(
    title = "Distribution of the number of characters in an email \n based on the size of the number in the email", 
    x = "Size of number in email", 
    y = "Number of characters"
  )
```




## Changing colors 

Full guide on how to change colors in `ggplot2` at [https://r-graph-gallery.com/ggplot2-color.html](https://r-graph-gallery.com/ggplot2-color.html)

::: {.panel-tabset}
## Manual

```{r}
#| source-line-numbers: "2"
ggplot(email, aes(x=number, fill=number)) + geom_bar() +
    scale_fill_manual(values=c("red", "green", "blue"))
```

There's some spectacularly colors available. See [https://r-charts.com/colors/](https://r-charts.com/colors/) for the full list. You can also type `colors()` in the console. 

```{r}
ggplot(email, aes(x=number, fill=number)) + geom_bar() +
    scale_fill_manual(values=c("salmon", "slategray4", "violet"))
```
 
And you can use [hex colors](https://www.w3schools.com/colors/colors_picker.asp)
```{r}
ggplot(email, aes(x=number, fill=number)) + geom_bar() +
    scale_fill_manual(values=c("#47dbff", "#b3b3cc", "#ff531a"))
```

## Using a color palette (recommended)

There are 3 types of palettes:

* **_Sequential_** palettes are suited to ordered data that progress from low to high. Lightness steps dominate the look of these schemes, with light colors for low data values to dark colors for high data values.

* **_Diverging_** palettes put equal emphasis on mid-range critical values and extremes at both ends of the data range. The critical class or break in the middle of the legend is emphasized with light colors and low and high extremes are emphasized with dark colors that have contrasting hues.

* **_Qualitative_** palettes do not imply magnitude differences between legend classes, and hues are used to create the primary visual differences between classes. Qualitative schemes are best suited to representing nominal or categorical data.

### R ColorBrewer
One of the most common color pallet packages used. See the [full set of palettes available](https://r-graph-gallery.com/38-rcolorbrewers-palettes.html). 

The function to use is `scale_fill_brewer` (or `scale_color_brewer`), with an argument specifying the palette name in quotes. 

```{r}
library(RColorBrewer)
ggplot(email, aes(x=number, fill=number)) + geom_bar() +
    scale_fill_brewer(palette = "Dark2")
```

### Viridis

`viridis` provide a series of color maps that are designed to improve graph readability for readers with common forms of color blindness and/or color vision deficiency. [Eight scales are available](https://sjmgarnier.github.io/viridisLite/reference/viridis.html), but `magma`, `inferno`, `plasma`, and `viridis` as defined in Matplotlib for Python. These color maps are designed in such a way that they will analytically be perfectly perceptually-uniform, both in regular form and also when converted to black-and-white. They are also designed to be perceived by readers with the most common form of color blindness. 

If you are `fill`ing or `col`oring by a categorical variable, you'll use the corresponding `scale_fill_discrete` or `scale_color_discrete` function, and then pass the name of the palette with the number of levels needed as a function to the `palette` argument. 

```{r}
library(viridisLite)
ggplot(email, aes(x=number, fill=number)) + geom_bar() +
    scale_fill_discrete(palette = magma(3))
```

:::


## Multivariate plotting 

:::{.callout-warning icon=false appearance=minimal}
<a href="https://media.csuchico.edu/media/MATH+130+-+Lecture+10A+Multivariate+Plotting/1_xp1whb0f" target="_blank">Multivariate plotting video</a>
:::

So far we've only looked at how to plot 2 variables on the same plot. Let's up our game some. 

::: {.panel-tabset}
## Boxplots with three variables

In the first plotting lesson, we `fill`ed the boxes with the same categorical variable that was on the x axis. We can also fill (or color) the boxes by a third variable if you want an additional comparison. 

```{r}
ggplot(NCbirths, aes(y=weeks, x=mature, fill=habit)) + geom_boxplot()
```

This lets us compare the distribution of gestation period for smokers vs non smokers, within mature and younger moms. 

## Scatterplots

```{r}
#| code-annotations: below
NCbirths %>%   # <1>
  select(weeks, weight, habit) %>% 
  filter(!is.na(habit)) %>% 
ggplot(aes(x=weeks, y=weight, color = habit)) +  # <2>
         geom_point() + geom_smooth(se=FALSE) + 
  theme_minimal() + scale_color_brewer(palette = "Set1") # <3>
```

1. Starting with the `NCbirths` data set, I `select` the variables i want to plot, and then use `filter` to drop rows with missing values for `habit`. 
2. Create a scatterplot for gestation `weeks` against baby `weight`, coloring by the mothers smoking `habit`. Add both points and loess lines. 
3. Make the graph more visually readable by modifying the theme and adding a color palette. 

:::


## Faceting / paneling 

ggplot introduces yet another term called `faceting`. The definition is _a particular aspect or feature of something_, or _one side of something many-sided, especially of a cut gem_. Basically instead of plotting the grouped graphics on the same plotting area, we let each group have it's own plot, or facet.  

We add a `facet_wrap()` and specify the variable we want to panel on after the `~` tilde. 

```{r}
#| source-line-numbers: "2"
ggplot(NCbirths, aes(x=mage, fill=gender)) + geom_density(alpha=.3) +
  facet_wrap(~mature)
```

The grid placement can be semi-controlled by using the `ncol` argument in the `facet_wrap()` statement. 

```{r, fig.height=6}
#| source-line-numbers: "2"
ggplot(NCbirths, aes(x=mage, fill=gender)) + geom_density(alpha=.3) +
  facet_wrap(~mature, ncol=1)
```

It is important to compare distributions across groups on the same scale, and our eyes can compare items vertically better than horizontally. 

### Paneling on two variables

Who says we're stuck with only faceting on one variable? Using`facet_grid(` we can specify multiple variables to panel on. 

```{r, fig.width=10, fig.height=5}
#| source-line-numbers: "2"
NCbirths %>%   # <1>
  select(weeks, marital, habit, mature) %>% 
  filter(!is.na(habit)) %>% 
ggplot(aes(x=weeks, fill=mature)) + geom_density(alpha=.2) + facet_grid(marital~habit)
```

* Distribution of weeks
* colored by maturity status
* paneled on the combination of smoking habit and marital status

## Multiple plots per window

We can set the number of columns figures show up in using code chunk option:  `layout-ncol`. This method works only in Quarto documents. 


```{r}
#| echo: fenced
#| layout-ncol: 2
ggplot(pen, aes(x=body_mass_g, fill=species)) + geom_density(alpha=.2)
ggplot(pen, aes(x=body_mass_g, col=island)) + geom_density() 
```






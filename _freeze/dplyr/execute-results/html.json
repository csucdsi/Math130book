{
  "hash": "7cef1cb4b61325482609fdd5cd5bd311",
  "result": {
    "engine": "knitr",
    "markdown": "# Data management and aggregation\n\n## Introduction <a href=\"https://media.csuchico.edu/media/MATH+130+Lecture+08A+Introduction/1_r7jhnwgd\" target=\"_blank\">(Video)</a>\n\nWhen working with data you must:\n\n1. Figure out what you want to do.\n2. Precisely describe what you want in the form of a computer program.\n3. Execute the code.\n\nThe dplyr package makes each of these steps as fast and easy as possible by:\n\n1. Elucidating the most common data manipulation operations, so that your\n   options are helpfully constrained when thinking about how to tackle a problem.\n2. Providing simple functions that correspond to the most common data \n   manipulation verbs, so that you can easily translate your thoughts into code.\n3. Using efficient data storage back ends, so that you spend as little time \n   waiting for the computer as possible.\n\n::: {.callout-note}\n### Learning Objectives\n\nAfter completing this lesson students will be able to\n\n* Explain the difference between a `data.table` and a `tibble`. \n* Build and execute a chain of command to accomplish a data management task\n* Extract certain rows using `select`. \n* Create new variables using `mutate`. \n* Rename variables using `rename`\n* Subset the data based on a criteria using `filter`.\n* Create summary statistics using `group_by` and `summarize`\n* Learn how to use code chunk options to disable warning messages. \n:::\n\n\n:::{.callout-important}\n#### Preparation\n\nPrior to this lesson students should\n\n* Download the [[08_dplyr_notes.Rmd]](08_dplyr_notes.Rmd) R markdown file and save into your `Math130/notes` folder. \n* Ensure that the `dplyr` and `nycflights13` packages are installed by running the first code chunk. \n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nflights <- nycflights13::flights\n```\n:::\n\n\n\n\n\n\n\n:::\n\n### Exploring airline flight data with dplyr. \n\nThe `nycflights13` package contains several data sets that can be used to help understand what causes delays. We will be using the `flights` data set which contains information about all flights that departed from NYC (e.g. EWR, JFK and LGA) in 2013. \n\n### Tibbles\n\nThe `flights` data set, and any data set created with `dplyr`, has a specific data type called a `tibble`. These are not as furry and prolific as their cousins the `tribbles`. `tibbles` behaves for all intents and purposes as a `data.frame`, just gets displayed differently. For example, the `flights` data set contains data on 19 characteristics (variables) from 336,776 flights. There's no way I would want to print out a data set that large. But I'm gonna....  \n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nThe output has been trimmed to something more reasonable for our viewing pleasure. This may not seem such a big deal because R Studio already provides some level of truncation for our viewing pleasure. \n\n## Basic verbs <a href=\"https://media.csuchico.edu/media/MATH+130+Lecture+08A+Basic+Verbs/1_ndesnisk\" target=\"_blank\">(Video)</a>\nThe `dplyr` package contains new data manipulation functions, also called verbs. We will look at the following verbs: \n\n* `filter()`: Returns a subset of the rows.\n* `select()`: Returns only the listed columns.\n* `rename()`: Renames the variables listed. \n* `mutate()`: Adds columns from existing data.\n* `summarise()`: Reduces each group to a single row by calculating aggregate measures.\n* `group_by()`: Groups a data set on a factor variable, such that all functions performed are then done on each level of the factor.\n\n\n### Filter\n`filter()` allows you to select a subset of the rows of a data frame. \nThe first argument is the name of the data frame, and the second and subsequent are filtering expressions evaluated in the context of that data frame. For example, we can select all flights on January 1st with \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(flights, month == 1, day == 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 842 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 832 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n`filter()` works similarly to `subset()` except that you can give it any number of filtering conditions which are joined together with &. You can use other Boolean operators explicitly. Here we select flights in January or February.\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(flights, month == 1 | month == 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 51,955 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 51,945 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n### Select\nOften you work with large data sets with many columns where only a few are actually of interest to you. `select()` allows you to rapidly zoom in on a useful subset using operations that usually only work on numeric variable positions.\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(flights, month, day, year)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 3\n   month   day  year\n   <int> <int> <int>\n 1     1     1  2013\n 2     1     1  2013\n 3     1     1  2013\n 4     1     1  2013\n 5     1     1  2013\n 6     1     1  2013\n 7     1     1  2013\n 8     1     1  2013\n 9     1     1  2013\n10     1     1  2013\n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nYou can use a colon (:) to select all columns physically located between two variables. \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(flights, year:day)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 3\n    year month   day\n   <int> <int> <int>\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nTo exclude specific columns you use the minus sign (-)\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(flights, -carrier)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 18\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 10 more variables: arr_delay <dbl>, flight <int>, tailnum <chr>,\n#   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#   minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nThis also works to exclude all columns EXCEPT the ones between two variables. \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(flights, -(year:day))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 16\n   dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier\n      <int>          <int>     <dbl>    <int>          <int>     <dbl> <chr>  \n 1      517            515         2      830            819        11 UA     \n 2      533            529         4      850            830        20 UA     \n 3      542            540         2      923            850        33 AA     \n 4      544            545        -1     1004           1022       -18 B6     \n 5      554            600        -6      812            837       -25 DL     \n 6      554            558        -4      740            728        12 UA     \n 7      555            600        -5      913            854        19 B6     \n 8      557            600        -3      709            723       -14 EV     \n 9      557            600        -3      838            846        -8 B6     \n10      558            600        -2      753            745         8 AA     \n# ℹ 336,766 more rows\n# ℹ 9 more variables: flight <int>, tailnum <chr>, origin <chr>, dest <chr>,\n#   air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n### Rename\nSometimes variables come to you in really obscure naming conventions. What the heck is SBA641? New to `dplyr` 1.0.0 is the `rename()` function. Works like magic to convert `old name` to a `new name`. The generic syntax is `rename(new = old)`\n\nSo to rename `dep_time` to `departure_time` we would type\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrename(flights, departure_time = dep_time)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day departure_time sched_dep_time dep_delay arr_time\n   <int> <int> <int>          <int>          <int>     <dbl>    <int>\n 1  2013     1     1            517            515         2      830\n 2  2013     1     1            533            529         4      850\n 3  2013     1     1            542            540         2      923\n 4  2013     1     1            544            545        -1     1004\n 5  2013     1     1            554            600        -6      812\n 6  2013     1     1            554            558        -4      740\n 7  2013     1     1            555            600        -5      913\n 8  2013     1     1            557            600        -3      709\n 9  2013     1     1            557            600        -3      838\n10  2013     1     1            558            600        -2      753\n# ℹ 336,766 more rows\n# ℹ 12 more variables: sched_arr_time <int>, arr_delay <dbl>, carrier <chr>,\n#   flight <int>, tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>,\n#   distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nThe variable name on the 3rd column now says `departure_time` instead of `dep_time`. \n\n> For the purpose of these lecture notes I am not making this change permenant. There is no assignment operator `<-` used here, so this change is not going to persist into later code. \n\n### Mutate\nAs well as selecting from the set of existing columns, it's often useful to add new columns that are functions of existing columns. This is the job of `mutate()`!\n\nHere we create two variables: gain (as arrival delay minus departure delay) and speed (as distance divided by time, converted to hours). \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- mutate(flights, gain = arr_delay - dep_delay, \n                speed = distance / air_time * 60)\nselect(a, gain, distance, air_time, speed)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 4\n    gain distance air_time speed\n   <dbl>    <dbl>    <dbl> <dbl>\n 1     9     1400      227  370.\n 2    16     1416      227  374.\n 3    31     1089      160  408.\n 4   -17     1576      183  517.\n 5   -19      762      116  394.\n 6    16      719      150  288.\n 7    24     1065      158  404.\n 8   -11      229       53  259.\n 9    -5      944      140  405.\n10    10      733      138  319.\n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\nOne key advantage of mutate is that you can refer to the columns you just created. Mutate flights to create two variables, `gain = arr_delay - dep_delay` and `gain_per_hour = gain / (air_time / 60)`. \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(flights, gain = arr_delay - dep_delay, \n                gain_per_hour = gain / (air_time / 60 ))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 21\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 13 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>, gain <dbl>, gain_per_hour <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n### Summarize\nThe last verb is `summarise()`, which collapses a data frame to a single row. It's not very useful yet. We can create a new variable called delay that is the average departure delay on the entire flights data set. \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(flights, delay = mean(dep_delay, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  delay\n  <dbl>\n1  12.6\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n## Grouped Operations  <a href=\"https://media.csuchico.edu/media/MATH+130+Lecture+08A+Grouped+Operations/1_w9x1kd5m\" target=\"_blank\">(Video)</a>\n\nThe above verbs are useful, but they become really powerful when you combine them with the idea of \"group by\", repeating the operation individually on groups of observations within the dataset. In dplyr, you use the `group_by()` function to describe how to break a dataset down into groups of rows. You can then use the resulting object in exactly the same functions as above; they'll automatically work \"by group\" when the input is a grouped.\n\nLet's demonstrate how some of these functions work after grouping the flights data set by month. First we'll create a new data set that is grouped by month. \n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nby_month <- group_by(flights, month)\n```\n:::\n\n\n\n\n\n\n\n\n\n* The `summarise()` verb allows you to calculate summary statistics for each group. This is probably the most common function that is used in conjunction with `group_by`. For example, the average distance flown per month. \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(by_month, avg_airtime = mean(distance, na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 2\n   month avg_airtime\n   <int>       <dbl>\n 1     1       1007.\n 2     2       1001.\n 3     3       1012.\n 4     4       1039.\n 5     5       1041.\n 6     6       1057.\n 7     7       1059.\n 8     8       1062.\n 9     9       1041.\n10    10       1039.\n11    11       1050.\n12    12       1065.\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nOr simply the total number of flights per month. \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarize(by_month, count=n())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 2\n   month count\n   <int> <int>\n 1     1 27004\n 2     2 24951\n 3     3 28834\n 4     4 28330\n 5     5 28796\n 6     6 28243\n 7     7 29425\n 8     8 29327\n 9     9 27574\n10    10 28889\n11    11 27268\n12    12 28135\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n## Chaining Operations  <a href=\"https://media.csuchico.edu/media/MATH+130+Lecture+08A+Chaining+Operations/1_6xzk59i7\" target=\"_blank\">(Video)</a>\nConsider the following group of operations that take the data set `flights`, and produce a final data set (`a4`) that contains only the flights where the daily average delay is greater than a half hour. \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na1 <- group_by(flights, year, month, day)\na2 <- select(a1, arr_delay, dep_delay)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nAdding missing grouping variables: `year`, `month`, `day`\n```\n\n\n:::\n\n```{.r .cell-code}\na3 <- summarise(a2,\n                arr = mean(arr_delay, na.rm = TRUE),\n                dep = mean(dep_delay, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'year', 'month'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n```{.r .cell-code}\na4 <- filter(a3, arr > 30 | dep > 30)\nhead(a4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n# Groups:   year, month [3]\n   year month   day   arr   dep\n  <int> <int> <int> <dbl> <dbl>\n1  2013     1    16  34.2  24.6\n2  2013     1    31  32.6  28.7\n3  2013     2    11  36.3  39.1\n4  2013     2    27  31.3  37.8\n5  2013     3     8  85.9  83.5\n6  2013     3    18  41.3  30.1\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nIt does the trick, but what if you don't want to save all the intermediate results (`a1` - `a3`)? Well these verbs are `function`, so they can be wrapped inside other functions to create a nesting type structure.  \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(\n  summarise(\n    select(\n      group_by(flights, year, month, day),\n      arr_delay, dep_delay\n    ),\n    arr = mean(arr_delay, na.rm = TRUE),\n    dep = mean(dep_delay, na.rm = TRUE)\n  ),\n  arr > 30 | dep > 30\n)\n```\n:::\n\n\n\n\n\n\n\n\nWoah, that is HARD to read! This is difficult to read because the order of the operations is from inside to out, and the arguments are a long way away from the function. To get around this problem, dplyr provides the `%>%` operator. `x %>% f(y)` turns into `f(x, y)` so you can use it to rewrite multiple operations so you can read from left-to-right, top-to-bottom:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights %>%\n  group_by(year, month, day) %>%\n  select(arr_delay, dep_delay) %>%\n  summarise(\n    arr = mean(arr_delay, na.rm = TRUE),\n    dep = mean(dep_delay, na.rm = TRUE)\n  ) %>%\n  filter(arr > 30 | dep > 30)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nAdding missing grouping variables: `year`, `month`, `day`\n`summarise()` has grouped output by 'year', 'month'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 49 × 5\n# Groups:   year, month [11]\n    year month   day   arr   dep\n   <int> <int> <int> <dbl> <dbl>\n 1  2013     1    16  34.2  24.6\n 2  2013     1    31  32.6  28.7\n 3  2013     2    11  36.3  39.1\n 4  2013     2    27  31.3  37.8\n 5  2013     3     8  85.9  83.5\n 6  2013     3    18  41.3  30.1\n 7  2013     4    10  38.4  33.0\n 8  2013     4    12  36.0  34.8\n 9  2013     4    18  36.0  34.9\n10  2013     4    19  47.9  46.1\n# ℹ 39 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nAnother way you can read this is by thinking \"and then\" when you see the `%>%` \noperator. So the above code takes the data set flights  \n.. and then groups by day  \n.. and then selects the delay variables  \n.. and then calculates the means  \n.. and then filters on a delay over half hour. \n\nThe same 4 steps that resulted in the `a4` data set, but without all the intermediate data saved! This can be **very important** when dealing with Big Data. `R` stores all data in memory, so if your little computer only has 2G of RAM and you're working with a data set that is 500M in size, your computers memory will be used up fast. `a1` takes 500M, `a2` another 500M, by now your computer is getting slow. Make another copy at `a3` and it gets worse, `a4` now likely won't even be able to be created because you'll be out of memory. \n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
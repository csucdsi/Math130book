{
  "hash": "8a5227e4f2e17df0769d36214efb12cf",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute:\n  fig-width: 4\n  fig-height: 4\nformat: \n  html:\n    toc-depth: 3\n---\n\n\n\n\n# Creating Plots\n\n:::{.callout-warning icon=false appearance=minimal}\n<a href=\"https://media.csuchico.edu/media/MATH+130+Lecture+07A+Introduction/1_jlh6zm14\" target=\"_blank\">Introduction Video</a>\n:::\n\nVisualizing your data is hands down the most important thing you can learn to do. Seeing is critical to understanding. There are two audiences in mind when creating data visualizations: \n\n1. **(meh)** For your eyes only. These are quick and dirty plots, without annotation. Meant to be looked at once or twice.\n2. **(good)** To share with others. Nicer looking plots with more information, but not needing a lot of additional code to create. \n3. **(best)** Publication quality. These need to completely stand on their own. Informative captions, axes labels, titles, colors as needed, etc. We won't spend time on these in this lesson. \n\nThe functions from the `ggplot2` package, along with those from packages built on `ggplot2` such as `ggpubr` and `sjPlot`, automatically do a lot of this work for you. They can produce **good** and **better** quality plots with very little code and are quite extensible and flexible. \n\n:::{.callout-note title = \"ðŸŽ“ Learning Objectives\" icon=false}\n\nAfter completing this lesson students will be able to create basic statistical data visualizations for one and two variables, using multiple approaches. \n\n:::\n\n:::{.callout-tip title = \"ðŸ‘‰ Prepare\" icon=false}\n\n1.  Open your Math 130 R Project.\n2.  Right click and \"save as\" this lessons [[Quarto notes file]](notes/plot_notes.qmd) and save into your `notes/Math130` folder.\n3.  In the *Files* pane, open this Quarto file and Render this file.\n\n:::\n\n\n## The syntax of `ggplot`\n\nThe reason we use the functions in `ggplot2` is for consistency in the structure of it's arguments. Here is a bare bones generic plotting function: \n\n```r\nggplot(data, aes(x=x, y=y, col=col, fill=fill, group=group)) +  geom_THING() \n```\n\n### Required arguments {.unnumbered}\n\n* `data`: What data set is this plot using? This is ALWAYS the first argument.\n* `aes()`: This is the _aesthetics_ of the plot. What variable is on the x, and what is on the y? Do you want to color by another variable, perhaps fill some box by the value of another variable, or group by a variable. \n* `geom_THING()`: Every plot has to have a geometry. What is the shape of the thing you want to plot? Do you want to plot point? Use `geom_points()`. Want to connect those points with a line? Use `geom_lines()`. We will see many varieties in this lesson. \n\n:::{.callout-note icon = false title = \"The Diamonds Data\"}\nWe will use a subset of the `diamonds` dataset that comes with the `ggplot2` package. This dataset contains the prices and other attributes of almost 54,000 diamonds. Review `?diamonds` to learn about the variables we will be using. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(sjPlot)    \nlibrary(ggpubr)     \ndiamonds <- ggplot2::diamonds\nset.seed(1410) # Make the sample reproducible\ndsmall <- diamonds[sample(nrow(diamonds), 1000), ]\n```\n:::\n\n\n\n\n:::\n\n\n## One categorical variable\n\nBoth Nominal and Ordinal data types can be visualized using barcharts or pie charts.\n\n### Barchart\n\nA Barchart or barplot takes these frequencies, and draws bars along the X-axis where the height of the bars is determined by the frequencies seen in the table. \n\n::: {.panel-tabset}\n\n## Base R (meh)\n\nWe could create a frequency `table` and then `plot` the results.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(dsmall$cut) |> plot()\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-2-1.png){width=384}\n:::\n:::\n\n\n\n\n\n\n## `ggplot` (good)\n\nUsing `ggplot2` with the `geom_bar()` geometry layer gives us actual wide bars, and better axis labels. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dsmall, aes(x=cut)) + geom_bar()\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-3-1.png){width=384}\n:::\n:::\n\n\n\n\n\n## `sjPlot` (better)\n\nUsing the `plot_frq` function from the `sjPlot` package builds on the `geom_bar()` type plot from `ggplot`, but adds frequncies and relative percentages on the plot. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_frq(dsmall, \"cut\")\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-4-1.png){width=384}\n:::\n:::\n\n\n\n\n\nThis single graph provides a lot of good information and is a recommended choice to use. \n\n:::\n\n### Pie charts\n\nA pie chart is a circular statistical graphic which is divided into slices to illustrate percentages out of a whole. While pie charts are very widely used in the media and business, there are some major drawbacks in that \"_humans are pretty bad at reading angles_\" [(Ref: The Issue with Pie Chart)](https://www.data-to-viz.com/caveat/pie.html)\n\nSimilar to a barchart, we can convert the results of a `table` to a `pie` using base R. But the results are kinda \"meh\". \n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(dsmall$cut) |> pie()\n```\n:::\n\n\n\n\n\nNicer pie charts using `ggplot2` or `ggpubr` functions require the data set to be pre-aggregated, and so we will come back to these approaches in a later lesson. \n\n:::\n\n::: {.column width=\"50%\"}\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-6-1.png){width=384}\n:::\n:::\n\n\n\n\n:::\n::::\n\n\n## One continuous variable\n\nThe price, carat, and depth of the diamonds are all continuous numeric variables. We will see how to plot several types of appropriate visualizations including histograms, density plots, boxplots and violin plots. \n\n### Histogram\n\nRather than showing the value of each observation, we prefer to think of the value as belonging to a _bin_. The height of the bars in a histogram display the frequency of values that fall into those of those bins. \n\nSince the x-axis is continuous the bars touch. This is unlike the barchart that has a categorical x-axis, and vertical bars that are separated.\n\n::: {.panel-tabset}\n## Base R\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(dsmall$price)\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-7-1.png){width=384}\n:::\n:::\n\n\n\n\n\nThe base R function `hist` doesn't produce a pretty graph, but it's quick and easy to create. \n\n## `ggplot2`\n\nUsing the `ggplot2` package we can create a better looking histogram by adding the layer `geom_histogram()`. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dsmall, aes(x=price)) + geom_histogram()\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-8-1.png){width=384}\n:::\n:::\n\n\n\n\n\n## `ggpubr`\n\nIn contrast to `ggplot2`'s common starter code and different `geom`etries, the  `ggpubr` package uses specific functions for each type of plot. The `gghistogram` package makes a histogram very similar to the `ggplot2` default, but with a different theme applied (different appearance). Otherwise it's the same. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngghistogram(dsmall, x=\"price\")\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-9-1.png){width=384}\n:::\n:::\n\n\n\n\n\n:::{.callout-important title = \"Variables names in quotes\"}\nThis is a feature of `ggpubr` functions - variable names are always in quotes. \n:::\n\n::: \n\n### Density curves\n\nTo get a better idea of the true shape of the distribution we can \"smooth\" out the bins and create what's called a `density` plot or curve. Notice that the shape of this distribution curve is much... \"wigglier\" than the histogram may have implied. \n\n::: {.panel-tabset}\n\n## Base R\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndensity(dsmall$price) |> plot()\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-10-1.png){width=384}\n:::\n:::\n\n\n\n\n\nSimilar to `hist`, `plot`ting the `density` of a variable does create a plot, but it's pretty meh. \n\n## `ggplot2`\n\nWith `ggplot2` we use the `geom_density()` geometry to produce a nicer looking density plot with minimal additional code. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dsmall, aes(x=price)) + geom_density()\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-11-1.png){width=384}\n:::\n:::\n\n\n\n\n\n## `ggpubr`\n\nAnd the `ggdensity` function from the `ggpubr` package creates a very similar density plot with a different default theme. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggdensity(dsmall, x=\"price\")\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-12-1.png){width=384}\n:::\n:::\n\n\n\n\n\n:::\n\n### Boxplots\n\nAnother very common way to visualize the distribution of a continuous variable is using a boxplot. Boxplots are useful for quickly identifying where the bulk of your data lie. R specifically draws a \"modified\" boxplot where values that are considered outliers are plotted as dots. \n\n::: {.panel-tabset}\n## Base R\n\nNotice that the only axis labeled is the y=axis. Like a dotplot the x axis, or \"width\", of the boxplot is meaningless here. We can make the axis more readable by flipping the plot on its side. \n\n\n\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nboxplot(dsmall$price)           # left plot\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-13-1.png){width=384}\n:::\n\n```{.r .cell-code}\nboxplot(dsmall$price,           # right plot\n        horizontal = TRUE, \n        main=\"Distribution of diamond prices\", \n        xlab=\"Dollars\")\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-13-2.png){width=384}\n:::\n:::\n\n\n\n\n\nHorizontal is a bit easier to read in my opinion. \n\n## `ggplot2`\n\nWith `ggplot` you can create either a horizontal or vertical boxplot by specifying your numeric variable to be on either `x` or `y` . Notice the middle of the box is centered on 0, this is just a placeholder. This axis has no inherent meaning. \n\n\n\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nggplot(dsmall, aes(x=price)) + geom_boxplot() # left\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-14-1.png){width=384}\n:::\n\n```{.r .cell-code}\nggplot(dsmall, aes(y=price)) + geom_boxplot() # right\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-14-2.png){width=384}\n:::\n:::\n\n\n\n\n\n## `ggpubr`\nYou can also make a boxplot using the `ggbpxplot` function from the `ggpubr` package, however it you must specify that the quantitative variable is on the `y` axis. \n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggboxplot(dsmall, y=\"price\")\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-15-1.png){width=384}\n:::\n:::\n\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggboxplot(dsmall, x=\"price\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in (function (fun, data, x, y, combine = FALSE, merge = FALSE, color = \"black\", : argument \"y\" is missing, with no default\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n::::\n\n\n\n:::\n\n#### New variable\n\nBefore we move on, I want to see `price` displayed as ranges of 5,000 instead of a continuous measure from 0 to 20,000. I will us the `cut_width` function to create a new categorical variable here called `price_range`. [See this page for this, and other functions in ggplot that discretize numeric data into categorical ](https://ggplot2.tidyverse.org/reference/cut_interval.html). \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndsmall$price_range <- cut_width(dsmall$price/1000, width=5)\n```\n:::\n\n\n\n\n\nNotice I also divided price by 1000, so 2.5 means 2500. Now that `price_range` is a categorical variable, I can create a barchart to visualize the frequencies of each bin. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dsmall, aes(x=price_range)) + geom_bar()\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-18-1.png){width=384}\n:::\n:::\n\n\n\n\n\n## Categorical v. Categorical\n\n#### Two-way Tables\nCross-tabs, cross-tabulations and two-way tables (all the same thing, different names) can be created by using the `table()` function. \n\n#### Frequency table\nThe frequency table is constructed using the `table()` function. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(dsmall$cut, dsmall$price_range)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           \n            [-2.5,2.5] (2.5,7.5] (7.5,12.5] (12.5,17.5] (17.5,22.5]\n  Fair              15        13          4           1           1\n  Good              41        45          8           5           0\n  Very Good        108        78         22          12           0\n  Premium          111        86         35          20           5\n  Ideal            237       103         34          14           2\n```\n\n\n:::\n:::\n\n\n\n\n\nThere are 4 Fair diamonds that cost between 7.5 and 12.5 thousand dollars, and 103 Ideal quality diamonds that cost between 2.5 and 7.5k. \n\n##### Cell proportions\nWrapping `prop.table()` around a table gives you the **cell** proportions. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(dsmall$cut, dsmall$price_range) |> prop.table()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           \n            [-2.5,2.5] (2.5,7.5] (7.5,12.5] (12.5,17.5] (17.5,22.5]\n  Fair           0.015     0.013      0.004       0.001       0.001\n  Good           0.041     0.045      0.008       0.005       0.000\n  Very Good      0.108     0.078      0.022       0.012       0.000\n  Premium        0.111     0.086      0.035       0.020       0.005\n  Ideal          0.237     0.103      0.034       0.014       0.002\n```\n\n\n:::\n:::\n\n\n\n\n\n* 1.5% of all diamonds are Fair cut and cost under 2.5k.\n* 0.5% of all diamonds are Premium cut and cost over 17.5k\n\n##### Row proportions\nTo get the **row** proportions, specify `margin=1`. The percentages now add up to 1 across the rows. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(dsmall$cut, dsmall$price_range) |> prop.table(margin=1) |> round(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           \n            [-2.5,2.5] (2.5,7.5] (7.5,12.5] (12.5,17.5] (17.5,22.5]\n  Fair           0.441     0.382      0.118       0.029       0.029\n  Good           0.414     0.455      0.081       0.051       0.000\n  Very Good      0.491     0.355      0.100       0.055       0.000\n  Premium        0.432     0.335      0.136       0.078       0.019\n  Ideal          0.608     0.264      0.087       0.036       0.005\n```\n\n\n:::\n:::\n\n\n\n\n\n* 44.1% of Fair quality diamonds cost under 2.5k\n* 1.9% of Premium quality diamonds cost over 17.5k.\n\n##### Column proportions\nTo get the **column** proportions, you specify `margin=2`. The percentages now add up to 1 down the columns. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(dsmall$cut, dsmall$price_range) |> prop.table(margin=2) |> round(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           \n            [-2.5,2.5] (2.5,7.5] (7.5,12.5] (12.5,17.5] (17.5,22.5]\n  Fair           0.029     0.040      0.039       0.019       0.125\n  Good           0.080     0.138      0.078       0.096       0.000\n  Very Good      0.211     0.240      0.214       0.231       0.000\n  Premium        0.217     0.265      0.340       0.385       0.625\n  Ideal          0.463     0.317      0.330       0.269       0.250\n```\n\n\n:::\n:::\n\n\n\n\n\n* 8% of diamonds that cost under 2.5k are of Good quality\n* 25% of diamonds that cost over 17.5k are Ideal quality\n\n#### Grouped bar charts\nTo compare proportions of one categorical variable within the same level of another, is to use grouped barcharts. \n\nPlot the cut on the x axis, but then `fill` using the second categorical variable. This has the effect of visualizing the **row** percents from the table above. Here it is the percent of `price_range`, within each type of `cut`. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dsmall, aes(x=cut, fill=price_range)) + geom_bar()\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-23-1.png){width=384}\n:::\n:::\n\n\n\n\n\nThe default is a stacked barchart. So add the argument `position=dodge` inside the `geom_bar` layer to put the bars side by side. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dsmall, aes(x=cut, fill=price_range)) + geom_bar(position = \"dodge\")\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-24-1.png){width=384}\n:::\n:::\n\n\n\n\n\nAnd look, an automatic legend. What if I wanted to better compare cut within price range? This is the **column** percentages. Just switch which variable is the x axis and which one is used to fill the colors!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dsmall, aes(x=price_range, fill=cut)) + geom_bar(position = \"dodge\")\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-25-1.png){width=384}\n:::\n:::\n\n\n\n\n\nAnd this easy change is why we love `ggplot2`. \n\n## Two continuous variables\n\nVisualizing the relationship between two continuous variables is done using a scatterplot. Let's compare the `carat` of a diamond to it's `price`. \n\n::: {.panel-tabset}\n## Base R\n\nUsing the generic `plot(x, y)` function we get a good enough, but kinda 'meh' scatterplot with `carat` on the x axis and `price` on the y axis. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(dsmall$carat, dsmall$price)\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-26-1.png){width=384}\n:::\n:::\n\n\n\n\n \n## `ggplot2`\n\nWith ggplot we specify both the x and y variables, and add `geom_point` geometry layer. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dsmall, aes(x=carat, y=price)) + geom_point()\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-27-1.png){width=384}\n:::\n:::\n\n\n\n\n\n## `ggpubr`\n\nThe `ggscatter` function creates a similar scatterplot. Notice again that the variable names must be in quotes, compared to not in quotes when using `ggplot2`. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggscatter(dsmall, x=\"carat\", y=\"price\")\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-28-1.png){width=384}\n:::\n:::\n\n\n\n\n:::\n\n\n## One continuous vs. one categorical \n\nThe tactic here is to create an appropriate plot for a continuous variable, and plot it for each level of the categorical variable by shading or coloring the lines depending on the level.  \n\n### Histograms\n\n### Density curves\n\nYou could `fill` the density curves depending on the group, but then it's hard to see overlap. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dsmall, aes(x=depth, fill=cut)) + geom_density()\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-29-1.png){width=384}\n:::\n:::\n\n\n\n\n\nWe can adjust the transparency of the density curve by applying a value to `alpha` inside the density layer. Alpha is a measure of transparency, from 0=clear to 1=opaque. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dsmall, aes(x=depth, fill=cut)) + geom_density(alpha=.3)\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-30-1.png){width=384}\n:::\n:::\n\n\n\n\n\nNow we can see that there are some premium cut diamonds with depths around 62. This peak was hidden from us before. \n\nYou could also just color the lines and leave the fill alone. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dsmall, aes(x=depth, color=cut)) + geom_density()\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-31-1.png){width=384}\n:::\n:::\n\n\n\n\n\nWe won't talk about changing colors or the background in this lab, but the yellow is pretty hard to read. \n\n#### Using `ggpubr`\n\nThe `ggdensity` function also has a `color` and `fill` option. In addition to moving the legend to the top of the plot, the transparency of the density plots are automatically \n\n\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nggdensity(dsmall, x=\"depth\", color = \"cut\")\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-32-1.png){width=384}\n:::\n\n```{.r .cell-code}\nggdensity(dsmall, x=\"depth\", fill = \"cut\")\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-32-2.png){width=384}\n:::\n:::\n\n\n\n\n\n\n\n### Boxplots\n\nTo create basic grouped boxplots, put the continuous variable on one axis, and the categorical on the other axis. \n\n\n\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nggplot(dsmall, aes(x=price, y=cut)) + geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-33-1.png){width=384}\n:::\n\n```{.r .cell-code}\nggplot(dsmall, aes(x=cut, y=carat)) + geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-33-2.png){width=384}\n:::\n:::\n\n\n\n\n\nIf you want an additional color feature (and the corresponding legend), you can either `fill` or `color` the boxes by the same categorical variable. \n\n\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nggplot(dsmall, aes(x=price, y=cut, fill = cut)) + geom_boxplot() # left\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-34-1.png){width=384}\n:::\n\n```{.r .cell-code}\nggplot(dsmall, aes(x=cut, y=carat, color = cut)) + geom_boxplot() # right\n```\n\n::: {.cell-output-display}\n![](plots_files/figure-html/unnamed-chunk-34-2.png){width=384}\n:::\n:::\n",
    "supporting": [
      "plots_files/figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}